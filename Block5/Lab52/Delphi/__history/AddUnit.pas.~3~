Unit AddUnit;

Interface

Uses
    Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,
    System.Classes, Vcl.Graphics, Vcl.Grids,
    Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Clipbrd;

Type
    TAddForm = Class(TForm)
        NumberEdit: TEdit;
        AddButton: TButton;
        CancelButton: TButton;

        Procedure AddFormKeyDown(Sender: TObject; Var Key: Word; Shift: TShiftState);

        Procedure ComponentKeyDown(Sender: TObject; Var Key: Word; Shift: TShiftState);

        Procedure NumberEditChange(Sender: TObject);
        Procedure NumberEditContextPopup(Sender: TObject; MousePos: TPoint; Var Handled: Boolean);
        Procedure NumberEditKeyDown(Sender: TObject; Var Key: Word; Shift: TShiftState);
        Procedure NumberEditKeyPress(Sender: TObject; Var Key: Char);
        Procedure NumberEditKeyUp(Sender: TObject; Var Key: Word; Shift: TShiftState);

        Procedure AddButtonClick(Sender: TObject);
        Procedure CloseButtonClick(Sender: TObject);

    Private
        { Private declarations }
    Public
        { Public declarations }
    End;

Const
    ENTER = #13;
    BACKSPACE = #8;
    NONE = #0;
    DIGITS = ['0'..'9'];
    ALPHABET = ['A'..'Z', 'a'..'z'];

Var
    AddForm: TAddForm;
    CtrlPressed: Boolean = False;

Implementation

{$R *.dfm}

Uses MainUnit;

Procedure TAddForm.AddFormKeyDown(Sender: TObject; Var Key: Word; Shift: TShiftState);
Begin
    If Key = VK_ESCAPE Then
        Close;
End;



Function IsPossiblePaste(SelStart, SelLength: Integer; Text: String; Const MIN, MAX: Integer) : Boolean;
Var
    Num: Integer;
Begin
    IsPossiblePaste := Clipboard.HasFormat(CF_TEXT) And (Length(ClipBoard.AsText) <> 0) And
                       TryStrToInt(Copy(Text, 1, SelStart) + ClipBoard.AsText + Copy(Text, SelStart + SelLength + 1), Num) And
                       ((SelStart = 0) And (ClipBoard.AsText[1] <> '0') Or (SelStart > 0)) And
                       IsValidRange(StrToInt(Copy(Text, 1, SelStart) + ClipBoard.AsText + Copy(Text, SelStart + SelLength + 1)), MIN, MAX);
End;

Function IsValidChar(SelStart: Integer; Key: Char) : Boolean;
Begin
    IsValidChar := (SelStart = 0) And CharInSet(Key, DIGITS_WITHOUT_ZERO) Or (SelStart > 0) And CharInSet(Key, DIGITS);
End;

Procedure DrawNumsStringGrid(NumsStringGrid: TStringGrid; ColCount: Integer);
Const
    FixedRow = 0;
Var
    I: Integer;
Begin
    NumsStringGrid.ColCount := ColCount;
    For I := 0 To NumsStringGrid.ColCount - 1 Do
        NumsStringGrid.Cells[I, FixedRow] := IntToStr(I + 1);
    NumsStringGrid.ScrollBars := ssNone;
    NumsStringGrid.Width := NumsStringGrid.ColCount * (NumsStringGrid.DefaultColWidth + NumsStringGrid.GridLineWidth) + NumsStringGrid.GridLineWidth + 2;
    NumsStringGrid.Height := 82; // 2 * (NumsStringGrid.DefaultRowHeight + NumsStringGrid.GridLineWidth) + NumsStringGrid.GridLineWidth
    NumsStringGrid.Enabled := True;
    NumsStringGrid.Visible := True;
End;

Function AreFormNumsDifferent(NumsStringGrid: TStringGrid) : Boolean;
Const
    NumsRow = 1;
Var
    IsDifferent: Boolean;
    Col: Integer;
Begin
    IsDifferent := True;
    If NumsStringGrid.Cells[NumsStringGrid.Col, NumsRow] <> '' Then
    Begin
        Col := 0;
        While IsDifferent And (Col < NumsStringGrid.ColCount) Do
        Begin
            If (Col <> NumsStringGrid.Col) And (NumsStringGrid.Cells[NumsStringGrid.Col, NumsRow] = NumsStringGrid.Cells[Col, NumsRow]) Then
                IsDifferent := False;
            Inc(Col);
        End;
    End;
    AreFormNumsDifferent := IsDifferent;
End;

Procedure DeleteIdentical(NumsStringGrid: TStringGrid);
Const
    NumsRow = 1;
Var
    Col1, Col2: Integer;
    IsIdentical: Boolean;
Begin
    IsIdentical := False;
    Col1 := 0;
    Repeat
        Col2 := Col1 + 1;
        Repeat
            If (NumsStringGrid.Cells[Col1, NumsRow] <> '') And (NumsStringGrid.Cells[Col1, NumsRow] = NumsStringGrid.Cells[Col2, NumsRow]) Then
            Begin
                IsIdentical := True;
                NumsStringGrid.Cells[Col2, NumsRow] := '';
                Application.MessageBox('Натуральные числа должны быть различными!', 'Ошибка', MB_OK Or MB_ICONERROR);
            End;
            Inc(Col2);
        Until IsIdentical Or (Col2 >= NumsStringGrid.ColCount);
        Inc(Col1);
    Until IsIdentical Or (Col1 >= NumsStringGrid.ColCount);
End;



Procedure ComponentChange();
Begin
    If MainForm.ResultStringGrid.Cells[0, 0] <> '' Then
        ClearStringGrid(MainForm.ResultStringGrid);
    IsSaved := True;
    MainForm.SaveMenuItem.Enabled := False;
End;

Procedure ComponentKeyDown(Var Key: Word; Shift: TShiftState; SelStart, SelLength: Integer; Text: String; Const MIN, MAX: Integer);
Begin
    If (Shift = [ssCtrl]) And (UpCase(Chr(Key)) = 'X') Then
    Begin
        If (SelLength = 0) And (SelStart = 1) And (Length(Text) > 1) And (Text[2] = '0') Or
           (SelLength > 0) And (SelStart = 0) And (SelLength <> Length(Text)) And (Text[SelLength + 1] = '0') Then
            Key := Ord(NONE);
    End
    Else If Key = VK_DELETE Then
    Begin
        If (SelLength = 0) And (SelStart = 0) And (Length(Text) > 1) And (Text[2] = '0') Or
           (SelLength > 0) And (SelStart = 0) And (SelLength <> Length(Text)) And (Text[SelLength + 1] = '0') Then
            Key := Ord(NONE);
    End
    Else If (Shift = [ssCtrl]) And (UpCase(Chr(Key)) = 'V') Or (Shift = [ssShift]) And (Key = VK_INSERT) Then
    Begin
        If Not IsPossiblePaste(SelStart, SelLength, Text, MIN, MAX) Then
            Key := Ord(NONE);
    End;
    If (Shift = [ssCtrl]) And CharInSet(Chr(Key), ALPHABET) Then
        CtrlPressed := True;
End;

Procedure ComponentKeyPress(Var Key: Char; SelStart, SelLength: Integer; Text: String; Const MIN, MAX: Integer);
Begin
    If Key = BACKSPACE Then
    Begin
       If (SelLength = 0) And (SelStart = 1) And (Length(Text) > 1) And (Text[2] = '0') Or
          (SelLength > 0) And (SelStart = 0) And (SelLength <> Length(Text)) And (Text[SelLength + 1] = '0') Then
           Key := NONE;
    End
    Else If Key = ENTER Then
    Begin
        If IsFullFields() Then
            MainForm.ResultButtonClick(MainForm.ResultButton);
    End
    Else If Not CtrlPressed Then
    Begin
        If Not (IsValidChar(SelStart, Key) And IsValidRange(StrToInt(Copy(Text, 1, SelStart) + Key + Copy(Text, SelStart + SelLength + 1)), MIN, MAX)) Then
            Key := NONE;
    End;
End;

Procedure ComponentKeyUp();
Begin
    CtrlPressed := False;
End;



Procedure TAddForm.NumberEditChange(Sender: TObject);
Begin
    AddButton.Enabled := Length(NumberEdit.Text) = NumberEdit.MaxLength;
End;

Function IsPossiblePaste(SelStart, SelLength: Integer; Text: String) : Boolean;
Var
    Num: Integer;
Begin
    IsPossiblePaste := Clipboard.HasFormat(CF_TEXT) And (Length(ClipBoard.AsText) <> 0) And
                       TryStrToInt(Copy(Text, 1, SelStart) + ClipBoard.AsText + Copy(Text, SelStart + SelLength + 1), Num) And
                       (ClipBoard.AsText[1] <> '-');
End;

Procedure TAddForm.NumberEditContextPopup(Sender: TObject; MousePos: TPoint; Var Handled: Boolean);
Begin
     Handled := Not IsPossiblePaste(NumberEdit.SelStart, NumberEdit.SelLength, NumberEdit.Text);
End;

Procedure TAddForm.NumberEditKeyDown(Sender: TObject; Var Key: Word; Shift: TShiftState);
Begin
    ComponentKeyDown(NumberEdit, Key, Shift);
    If (Shift = [ssCtrl]) And (UpCase(Chr(Key)) = 'V') Or (Shift = [ssShift]) And (Key = VK_INSERT) Then
    Begin
        If Not IsPossiblePaste(NumberEdit.SelStart, NumberEdit.SelLength, NumberEdit.Text) Then
            Key := Ord(NONE);
    End;
    If (Shift = [ssCtrl]) And CharInSet(Chr(Key), ALPHABET) Then
        CtrlPressed := True;
End;

Procedure TAddForm.NumberEditKeyPress(Sender: TObject; Var Key: Char);
Begin
    If Not (CtrlPressed Or CharInSet(Key, DIGITS) Or (Key = BACKSPACE)) Then
        Key := NONE;
End;

Procedure TAddForm.NumberEditKeyUp(Sender: TObject; Var Key: Word; Shift: TShiftState);
Begin
    CtrlPressed := False;
End;



Procedure TAddForm.AddButtonClick(Sender: TObject);
Begin
    Add(TLimitedString('+375' + NumberEdit.Text));
    MainForm.NumberStringGrid.RowCount := MainForm.NumberStringGrid.RowCount + 1;
    WriteLinkedList(MainForm.NumberStringGrid);

    IsEdited := True;
    Close;
End;

Procedure TAddForm.CloseButtonClick(Sender: TObject);
Begin
    Close;
End;

End.
