Unit BinarySearchTree;

Interface

Uses
    Vcl.Graphics, Vcl.ExtCtrls;

Type
    TData = Integer;
    TBinarySearchTree = ^TNode;

    TNode = Record
        Data: TData;
        Left, Right: TBinarySearchTree;
    End;

    ERRORS_CODE = (CORRECT,
                   ALREADY_INSERT_NODE,
                   NOT_EXIST_NODE);

Procedure Create(BinarySearchTree: TBinarySearchTree; Data: TData);
Procedure Insert(BinarySearchTree: TBinarySearchTree; Data: TData; Var Error: ERRORS_CODE);
Procedure Remove(BinarySearchTree: TBinarySearchTree; Data: TData; Var Error: ERRORS_CODE);
Procedure Clear(BinarySearchTree: TBinarySearchTree);

Implementation

Procedure Create(BinarySearchTree: TBinarySearchTree; Data: TData);
Begin
    New(BinarySearchTree);
    BinarySearchTree.Data := Data;
    BinarySearchTree.Left := Nil;
    BinarySearchTree.Right := Nil;
End;

Procedure Insert(BinarySearchTree: TBinarySearchTree; Data: TData; Var Error: ERRORS_CODE);
Var
    ParentNode: TBinarySearchTree;
Begin
    Error := CORRECT;
    If BinarySearchTree = Nil Then
        Create(BinarySearchTree, Data)
    Else
    Begin
        While BinarySearchTree <> Nil Do
        Begin
            ParentNode := BinarySearchTree;
            If BinarySearchTree.Data > Data Then
                BinarySearchTree := BinarySearchTree.Left
            Else If BinarySearchTree.Data < Data Then
                BinarySearchTree := BinarySearchTree.Right
            Else
                Error := ALREADY_INSERT_NODE;    
        End;
        If Error = CORRECT Then
        Begin
            If ParentNode.Data > Data Then
            Begin
                New(ParentNode.Left);
                BinarySearchTree := ParentNode.Left;
            End
            Else
            Begin
                New(ParentNode.Right);
                BinarySearchTree := ParentNode.Right;
            End;
            BinarySearchTree.Data := Data;
            BinarySearchTree.Left := Nil;
            BinarySearchTree.Right := Nil;
        End;
    End;
End;

Procedure Remove(BinarySearchTree: TBinarySearchTree; Data: TData; Var Error: ERRORS_CODE);
Var
    RemovedNode: TBinarySearchTree;
Begin
    While (BinarySearchTree.Data <> Data) And (BinarySearchTree <> Nil) Do
    Begin
        If BinarySearchTree.Data > Data Then
            BinarySearchTree := BinarySearchTree.Left
        Else
            BinarySearchTree := BinarySearchTree.Right;
    End;
    If BinarySearchTree = Nil Then
        Error := NOT_EXIST_NODE 
    Else
    Begin
        While BinarySearchTree.Left <> Nil Do
        Begin
            BinarySearchTree.Data := BinarySearchTree.Left.Data;
            BinarySearchTree := BinarySearchTree.Left;
        End;
        RemovedNode := BinarySearchTree.Right;
        BinarySearchTree.Data := BinarySearchTree.Right.Data;
        BinarySearchTree.Left := BinarySearchTree.Right.Left;
        BinarySearchTree.Right := BinarySearchTree.Right.Right;
        Dispose(RemovedNode);
    End;
End;

Procedure Clear(BinarySearchTree: TBinarySearchTree);
Begin
    If BinarySearchTree <> Nil Then
    Begin
        Clear(BinarySearchTree.Left);
        Clear(BinarySearchTree.Right);
        Dispose(BinarySearchTree);
    End;
End;



Procedure DrawNodes(BinarySearchTree: TBinarySearchTree; PaintBox: TPaintBox; X, Y: Integer);
Begin
    if BinarySearchTree <> Nil then
    Begin
        With PaintBox.Canvas Do
        Begin
            Pen.Color := clBlack;
            Ellipse(X, Y, X + 20, Y + 20);
            DrawNodes(BinarySearchTree.Left, PaintBox, Round(Sqrt(X)), Y);
            DrawNodes(BinarySearchTree.Right, PaintBox, Round(Sqrt(X)), Y);
        End;
    End;
End;

Procedure Draw(BinarySearchTree: TBinarySearchTree; PaintBox: TPaintBox);
Begin
    With PaintBox.Canvas Do
    Begin
        Pen.Color := clBlack;
        Ellipse(10, 20, 10, 20);
        DrawNodes(BinarySearchTree, PaintBox, Round(Sqrt(X)), Y);
    End;
End;

End.
