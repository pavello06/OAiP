Program Lab33;
uses
  System.SysUtils;

Type
    TArr = Array Of Integer;
    ERRORS_CODE = (CORRECT,
                   INCORRECT_SET_LENGTH,
                   INCORRECT_SET_El,
                   INCORRECT_CHOICE,
                   IS_NOT_TXT,
                   IS_NOT_EXIST,
                   IS_NOT_READABLE,
                   IS_NOT_WRITEABLE,
                   INCORRECT_SET_AMOUNT);
Const
    MIN_LEN_A = 1;
    MAX_LEN_A = 100;
    MIN_A = -1000000;
    MAX_A = 1000000;
    ERRORS: Array [ERRORS_CODE] Of String = ( '',
                                              'Длина множества не попадает в диапазон!',
                                              'Элементы множества разделяются пробелом!',
                                              'Некорректный выбор!',
                                              'Расширение файла не .txt!',
                                              'Проверьте корректность ввода пути к файлу!',
                                              'Файл закрыт для чтения!',
                                              'Файл закрыт для записи!',
                                              'Неправильное число множеств в файле');
Procedure PrintTask();
Begin
    WriteLn('Данная программа реализует метод сортировки двухпутевыми ставками.');
End;
Function IsCorrectArrLen(Arr: TArr) : ERRORS_CODE;
Var
    Error: ERRORS_CODE;
Begin
    Error := CORRECT;
    If (SetLen < MIN_S) Or (SetLen > MAX_S) Then
        Error := INCORRECT_SET_LENGTH;
    IsCorrectSetLen := Error;
End;
Function IsCorrectSetEl(SSetEl: String) : ERRORS_CODE;
Var
    Error: ERRORS_CODE;
    I: Integer;
Begin
    Error := CORRECT;
    I := 2;
    While (Error = CORRECT) And (I <= Length(SSetEl)) Do
    Begin
        If SSetEl[I] <> ' ' Then
            Error := INCORRECT_SET_El;
        Inc(I, 2);
    End;
    IsCorrectSetEl := Error;
End;
Procedure FillSet(SSetEl: String; Var SetEl: TSet);
Var
    I: Integer;
Begin
    I := 1;
    While I <= Length(SSetEl) Do
    Begin
        Include(SetEl, AnsiChar(SSetEl[I]));
        Inc(I, 2);
    End;
End;
Function ChooseOption(Amount: Integer) : Integer;
Var
    Error: ERRORS_CODE;
    SOption: String;
    IOption: Integer;
Begin
    IOption := 1;
    Repeat
        Error := CORRECT;
        ReadLn(SOption);
        Try
            IOption := StrToInt(SOption)
        Except
            Error := INCORRECT_CHOICE;
        End;
        If (Error = CORRECT) And ((IOption < 1) Or (IOption > Amount)) Then
            Error := INCORRECT_CHOICE;
        If Error <> CORRECT Then
            WriteLn(ERRORS[Error], #13#10'Повторите попытку: ');
    Until Error = CORRECT;
    ChooseOption := IOption;
End;
Function GetPartStr(Str: String; PosStart, PosEnd: Integer) : String;
Var
    PartStr: String;
    I: Integer;
Begin
    partStr := '';
    For I := PosStart To PosEnd Do
        PartStr := PartStr + Str[I];
    GetPartStr := PartStr;
End;
Function IsFileTXT(PathToFile: String) : ERRORS_CODE;
Var
    Error: ERRORS_CODE;
Begin
    Error := CORRECT;
    If (Length(PathToFile) < 5) Or (GetPartStr(PathToFile, Length(PathToFile) - 3, Length(PathToFile)) <> '.txt') Then
        Error := IS_NOT_TXT;
    IsFileTXT := Error;
End;
Function IsExist(PathToFile: String) : ERRORS_CODE;
Var
    Error: ERRORS_CODE;
Begin
    Error := CORRECT;
    If Not FileExists(PathToFile) Then
        Error := IS_NOT_EXIST;
    IsExist := Error;
End;
Function IsReadable(Var F: TextFile) : ERRORS_CODE;
Var
    Error: ERRORS_CODE;
Begin
    Error := CORRECT;
    Try
        Reset(F);
        CloseFile(F);
    Except
        Error := IS_NOT_READABLE;
    End;
    IsReadable := Error;
End;
Function IsWriteable(Var F: TextFile) : ERRORS_CODE;
Var
    Error: ERRORS_CODE;
Begin
    Error := CORRECT;
    Try
        Append(F);
        CloseFile(F);
    Except
        Error := Is_NOT_WRITEABLE;
    End;
    IsWriteable := Error;
End;
Function IsCorrectSetAmount(Var F: TextFile) : ERRORS_CODE;
Var
    Error: ERRORS_CODE;
    Count, StopAmount: Integer;
Begin
    Error := CORRECT;
    Count := 0;
    StopAmount := AMOUNT_S + 1;
    Reset(F);
    While (Not EOF(F)) And (Count <> StopAmount) Do
    Begin
        ReadLn(F);
        Inc(Count);
    End;
    CloseFile(F);
    If Count <> AMOUNT_S Then
        Error := INCORRECT_SET_AMOUNT;
    IsCorrectSetAmount := Error;
End;
Function IsCorrectFileSet(Var F: TextFile) : ERRORS_CODE;
Var
    Error: ERRORS_CODE;
    SSetEl: String;
Begin
    Error := IsCorrectSetAmount(F);
    Reset(F);
    While (Error = CORRECT) And (Not EOF(F)) Do
    Begin
        ReadLn(F, SSetEl);
        Error := IsCorrectSetLen(SSetEl);
        If Error = CORRECT Then
            Error := IsCorrectSetEl(SSetEl);
    End;
    CloseFile(F);
    IsCorrectFileSet := Error;
End;
Procedure GetFileNormalReading(Var F: TextFile);
Var
    Error: ERRORS_CODE;
    PathToFile: String;
Begin
    WriteLn('Введите путь к файлу с расширением .txt с тремя множествами, с длинами[', MIN_S, '; ', MAX_S, ']: ');
    Repeat
        ReadLn(PathToFile);
        Error := IsFileTXT(PathToFile);
        If Error = CORRECT Then
            Error := IsExist(PathToFile);
        If Error = CORRECT Then
            AssignFile(F, PathToFile);
        If Error = CORRECT Then
            Error := IsReadable(F);
        If Error = CORRECT Then
            Error := IsCorrectFileSet(F);
        If Error <> CORRECT Then
            WriteLn(ERRORS[Error], #13#10'Повторите попытку: ');
    Until Error = CORRECT;
End;
Procedure GetFileNormalWriting(Var F: TextFile);
Var
    Error: ERRORS_CODE;
    PathToFile: String;
Begin
    WriteLn('Введите путь к файлу с расширением .txt для получения результата: ');
    Repeat
        ReadLn(PathToFile);
        Error := IsFileTXT(PathToFile);
        If Error = CORRECT Then
            Error := IsExist(PathToFile);
        If Error = CORRECT Then
            AssignFile(F, PathToFile);
        If Error = CORRECT Then
            Error := IsWriteable(F);
        If Error <> CORRECT Then
            WriteLn(ERRORS[Error], #13#10'Повторите попытку: ');
    Until Error = CORRECT;
End;
Procedure ReadFileSet(Var F: TextFile; Var SetEl: TSet);
Var
    SSetEl: String;
Begin
    ReadLn(F, SSetEl);
    FillSet(SSetEl, SetEl);
End;
Function IsCorrectConsoleSet(SSetEl: String) : ERRORS_CODE;
Var
    Error: ERRORS_CODE;
Begin
    Error := IsCorrectSetLen(SSetEl);
    If Error = CORRECT Then
        Error := IsCorrectSetEl(SSetEl);
    IsCorrectConsoleSet := Error;
End;
Procedure ReadConsoleArr(Var Arr: TArr);
Var
    Error: ERRORS_CODE;
Begin
    Write('Введите множество Х', Num, ' через пробелы: ');
    Repeat
        ReadLn(SSetEl);
        Error := IsCorrectConsoleSet(SSetEl);
        If Error <> CORRECT Then
            Write(ERRORS[Error], #13#10'Повторите попытку: ');
    Until Error = CORRECT;
    FillSet(SSetEl, SetEl);
End;
Procedure ReadArr(Var Arr: TArr);
Var
    RF: TextFile;
    Option: Integer;
Begin
    WriteLn('Вы хотите: ');
    WriteLn('Вводить массив через файл - 1');
    WriteLn('Вводить массив через консоль - 2');
    Option := ChooseOption(2);
    If Option = 1 Then
    Begin
        GetFileNormalReading(RF);
        Reset(RF);

        CloseFile(RF);
    End
    Else
    Begin
        ReadConsoleArr(Arr);
    End;
End;
Procedure PrintConsoleResult();
Begin

End;
Procedure PrintFileResult(Var F: TextFile);
Begin
    Append(F);

    CloseFile(F);
End;
Procedure PrintResult();
Var
    WF: TextFile;
    Option: Integer;
Begin
    WriteLn('Вы хотите: ');
    WriteLn('Выводить множества через файл - 1');
    WriteLn('Выводить множества через консоль - 2');
    Option := ChooseOption(2);
    If Option = 1 Then
    Begin
        GetFileNormalWriting(WF);
        PrintFileResult(WF);
    End
    Else
        PrintConsoleResult();
End;
Var
    Arr: TArr;
Begin
    PrintTask();

    PrintResult();
    ReadLn;
End.
