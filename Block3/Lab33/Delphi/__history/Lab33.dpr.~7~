Program Lab33;
Uses
    System.SysUtils;
Type
    TArr = Array Of Integer;
    TPosition = (PointerLeft, PointerRight);
    ERRORS_CODE = (CORRECT,
                   INCORRECT_RANGE,
                   INCORRECT_NUM,
                   INCORRECT_CHOICE,
                   IS_NOT_TXT,
                   IS_NOT_EXIST,
                   IS_NOT_READABLE,
                   IS_NOT_WRITEABLE,
                   INCORRECT_ARR_LEN,
                   EXTRA_DATA);
Const
    MIN_A = -1000000;
    MAX_A = 1000000;
    MIN_L = 1;
    MAX_L = 100;
    ERRORS: Array [ERRORS_CODE] Of String = ( '',
                                              'Значение не попадает в диапазон!',
                                              'Введено не число!',
                                              'Некорректный выбор!',
                                              'Расширение файла не .txt!',
                                              'Проверьте корректность ввода пути к файлу!',
                                              'Файл закрыт для чтения!',
                                              'Файл закрыт для записи!',
                                              'Неправильная длина массива!',
                                              'Лишние данные в файле');
Procedure PrintTask();
Begin
    WriteLn('Данная программа реализует сортировку двухпутевыми вставками.');
End;
Procedure PrintError(Error: ERRORS_CODE);
Begin
    WriteLn(ERRORS[Error], #13#10'Повторите попытку: ');
End;
Function IsCorrectRange(Num: Integer; Const MIN, MAX: Integer) : ERRORS_CODE;
Var
    Error: ERRORS_CODE;
Begin
    Error := CORRECT;
    If (Num < MIN) Or (Num > MAX) Then
        Error := INCORRECT_RANGE;
    IsCorrectRange := Error;
End;
Function ChooseOption(Quantity: Integer) : Integer;
Var
    Error: ERRORS_CODE;
    SOption: String;
    IOption: Integer;
Begin
    IOption := 1;
    Repeat
        Error := CORRECT;
        ReadLn(SOption);
        Try
            IOption := StrToInt(SOption)
        Except
            Error := INCORRECT_CHOICE;
        End;
        If (Error = CORRECT) And ((IOption < 1) Or (IOption > Quantity)) Then
            Error := INCORRECT_CHOICE;
        If Error <> CORRECT Then
            PrintError(Error);
    Until Error = CORRECT;
    ChooseOption := IOption;
End;
Function GetPartStr(Str: String; PosStart, PosEnd: Integer) : String;
Var
    PartStr: String;
    I: Integer;
Begin
    partStr := '';
    For I := PosStart To PosEnd Do
        PartStr := PartStr + Str[I];
    GetPartStr := PartStr;
End;
Function IsFileTXT(PathToFile: String) : ERRORS_CODE;
Var
    Error: ERRORS_CODE;
Begin
    Error := CORRECT;
    If (Length(PathToFile) < 5) Or (GetPartStr(PathToFile, Length(PathToFile) - 3, Length(PathToFile)) <> '.txt') Then
        Error := IS_NOT_TXT;
    IsFileTXT := Error;
End;
Function IsExist(PathToFile: String) : ERRORS_CODE;
Var
    Error: ERRORS_CODE;
Begin
    Error := CORRECT;
    If Not FileExists(PathToFile) Then
        Error := IS_NOT_EXIST;
    IsExist := Error;
End;
Function IsReadable(Var F: TextFile) : ERRORS_CODE;
Var
    Error: ERRORS_CODE;
Begin
    Error := CORRECT;
    Try
        Try
            Reset(F);
        Finally
            CloseFile(F);
        End;
    Except
        Error := IS_NOT_READABLE;
    End;
    IsReadable := Error;
End;
Function IsWriteable(Var F: TextFile) : ERRORS_CODE;
Var
    Error: ERRORS_CODE;
Begin
    Error := CORRECT;
    Try
        Try
            Append(F);
        Finally
            CloseFile(F);
        End;
    Except
        Error := Is_NOT_WRITEABLE;
    End;
    IsWriteable := Error;
End;
Procedure GetFileNormalReading(Var F: TextFile);
Var
    Error: ERRORS_CODE;
    PathToFile: String;
Begin
    Repeat
        ReadLn(PathToFile);
        Error := IsFileTXT(PathToFile);
        If Error = CORRECT Then
            Error := IsExist(PathToFile);
        If Error = CORRECT Then
            AssignFile(F, PathToFile);
        If Error = CORRECT Then
            Error := IsReadable(F);
        If Error <> CORRECT Then
            PrintError(Error);
    Until Error = CORRECT;
End;
Procedure GetFileNormalWriting(Var F: TextFile);
Var
    Error: ERRORS_CODE;
    PathToFile: String;
Begin
    Repeat
        ReadLn(PathToFile);
        Error := IsFileTXT(PathToFile);
        If Error = CORRECT Then
            Error := IsExist(PathToFile);
        If Error = CORRECT Then
            AssignFile(F, PathToFile);
        If Error = CORRECT Then
            Error := IsWriteable(F);
        If Error <> CORRECT Then
            PrintError(Error);
    Until Error = CORRECT;
End;
Function ReadFileNum(Var F: TextFile; Var Num: Integer; Const MIN, MAX: Integer) : ERRORS_CODE;
Var
    Error: ERRORS_CODE;
Begin
    Error := CORRECT;
    Try
        Read(F, Num);
    Except
        Error := INCORRECT_NUM;
    End;
    If Error = CORRECT Then
        Error := IsCorrectRange(Num, MIN, MAX);
    ReadFileNum := Error;
End;
Function ReadFileArrLen(Var F: TextFile; Var ArrLen: Integer) : ERRORS_CODE;
Var
    Error: ERRORS_CODE;
Begin
    Error := ReadFileNum(F, ArrLen, MIN_L, MAX_L);
    If (Error = CORRECT) And (Not EOLN(F)) Then
        Error := EXTRA_DATA;
    ReadFileArrLen := Error;
End;
Function ReadFileArr(Var F: TextFile; Var Arr: TArr; ArrLen: Integer) : ERRORS_CODE;
Var
    Error: ERRORS_CODE;
    I: Integer;
Begin
    SetLength(Arr, ArrLen);
    Error := CORRECT;
    I := 0;
    ReadLn(F);
    While (Error = CORRECT) And (Not EOLN(F)) Do
    Begin
        Error := ReadFileNum(F, Arr[I], MIN_A, MAX_A);
        Inc(I);
    End;
    If (Error = CORRECT) And (I <> ArrLen) Then
        Error := INCORRECT_ARR_LEN;
    If (Error = CORRECT) And (Not EOF(F)) Then
        Error := EXTRA_DATA;
    ReadFileArr := Error;
End;
Procedure ReadFileData(Var Arr: TArr; Var ArrLen: Integer);
Var
    Error: ERRORS_CODE;
    F: TextFile;
Begin
    WriteLn('Введите путь к файлу с расширением .txt с длиной массива[', MIN_L, '; ', MAX_L, '], и массивом с элементами в диапазоне[', MIN_A, '; ', MAX_A, ']: ');
    Repeat
        GetFileNormalReading(F);
        Reset(F);
        Error := ReadFileArrLen(F, ArrLen);
        If Error = CORRECT Then
            Error := ReadFileArr(F, Arr, ArrLen);
        CloseFile(F);
        If Error <> CORRECT Then
            PrintError(Error);
    Until Error = CORRECT;
End;
Procedure ReadConsoleNum(Var Num: Integer; Const MIN, MAX: Integer);
Var
    Error: ERRORS_CODE;
    SNum: String;
Begin
    Repeat
        Error := CORRECT;
        ReadLn(SNum);
        Try
            Num := StrToInt(SNum);
        Except
            Error := INCORRECT_NUM;
        End;
        If Error = CORRECT Then
            Error := IsCorrectRange(Num, MIN, MAX);
        If Error <> CORRECT Then
            PrintError(Error);
    Until Error = CORRECT;
End;
Procedure ReadConsoleArrLen(Var ArrLen: Integer);
Begin
    WriteLn('Введите длину массива в диапазоне[', MIN_L, ': ', MAX_L, ']: ');
    ReadConsoleNum(ArrLen, MIN_L, MAX_L);
End;
Procedure ReadConsoleArr(Var Arr: TArr; ArrLen: Integer);
Var
    I: Integer;
Begin
    SetLength(Arr, ArrLen);
    Write('Введите массив: ');
    For I := Low(Arr) To High(Arr) Do
    Begin
        Write(#13#10'Введите ', I + 1, ' элемент массива в диапазоне[', MIN_A, ': ', MAX_A, ']: ');
        ReadConsoleNum(Arr[I], MIN_A, MAX_A);
    End;
End;
Procedure ReadConsoleData(Var Arr: TArr; Var ArrLen: Integer);
Begin
    ReadConsoleArrLen(ArrLen);
    ReadConsoleArr(Arr, ArrLen);
End;
Procedure ReadArr(Var Arr: TArr; Var ArrLen: Integer);
Var
    Option: Integer;
Begin
    WriteLn('Вы хотите: ');
    WriteLn('Вводить массив через файл - 1');
    WriteLn('Вводить массив через консоль - 2');
    Option := ChooseOption(2);
    If Option = 1 Then
        ReadFileData(Arr, ArrLen)
    Else
        ReadConsoleData(Arr, ArrLen);
End;
Procedure SortArr(Arr: TArr; ArrLen: Integer; Var ResArr: TArr);
Var
    Arr1, Arr2: TArr;
    I, J, K, Midle, First, Last, Sort, Temp: Integer;
    Pos: TPosition;
Begin
    SetLength(ResArr, ArrLen * 2 - 1);
    Midle := ArrLen - 1;
    For I := Low(Arr) To High(Arr) Do
        Write(Arr[I]);
    WriteLn;
    For K := 1 To ArrLen * 2 Do
    Begin
        Pos := PointerRight;
        For I := Low(Arr) To High(Arr) Do
            ResArr[I + ArrLen - 1] := Arr[I];
        First := Midle;
        Last := Midle + 1;
        If ResArr[Midle] > ResArr[Midle + 1] Then
        Begin
            ResArr[Midle - 1] := ResArr[Midle + 1];
            First := Midle - 1;
            Last := Midle;
        End;
        For I := Midle + 2 To High(ResArr) Do
        Begin
            If Pos = PointerRight Then
            Begin
                If ResArr[I] >= ResArr[Last] Then
                Begin
                    ResArr[Last + 1] := ResArr[I]; 
                End
                Else
                Begin
                    Temp := ResArr[Last];
                    ResArr[Last] := ResArr[I];
                    ResArr[Last + 1] := Temp;
                    Pos := PointerLeft;
                End;
                Inc(Last);
            End
            Else
            Begin
                If ResArr[I] <= ResArr[First] Then
                Begin
                    ResArr[First - 1] := ResArr[I]; 
                End
                Else
                Begin
                    Temp := ResArr[First];
                    ResArr[First] := ResArr[I];
                    ResArr[First - 1] := Temp;
                    Pos := PointerRight;
                End;
                Dec(First);
            End;
        End;
        J := 0;
        For I := First To Last Do
        Begin
            Arr[J] := ResArr[I];
            Inc(J);
        End;
        For I := Low(Arr) To High(Arr) Do
            Write(Arr[I]);
        WriteLn;
    End;
End;
Procedure PrintConsoleResult();
Var
    Ch: AnsiChar;
Begin

End;
Procedure PrintFileResult();
Var
    F: TextFile;
    Ch: AnsiChar;
Begin
    WriteLn('Введите путь к файлу с расширением .txt для получения результата: ');
    GetFileNormalWriting(F);
    Append(F);

    CloseFile(F);
End;
Procedure PrintResult();
Var
    Option: Integer;
Begin
    WriteLn('Вы хотите: ');
    WriteLn('Выводить множества через файл - 1');
    WriteLn('Выводить множества через консоль - 2');
    Option := ChooseOption(2);
    If Option = 1 Then
        PrintFileResult()
    Else
        PrintConsoleResult();
End;
Var
    Arr, ResArr: TArr;
    ArrLen: Integer;
Begin
    ArrLen := 0;
    PrintTask();
    ReadArr(Arr, ArrLen);
    SortArr(Arr, ArrLen, ResArr);
    PrintResult();
    ReadLn;
End.
